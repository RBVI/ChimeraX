# === UCSF ChimeraX Copyright ===
# Copyright 2016 Regents of the University of California.
# All rights reserved.  This software provided pursuant to a
# license agreement containing restrictions on its disclosure,
# duplication and use.  For details see:
# http://www.rbvi.ucsf.edu/chimerax/docs/licensing.html
# This notice must be embedded in or attached to all copies,
# including partial copies, of the software or any revisions
# or derivations thereof.
# === UCSF ChimeraX Copyright ===

# -----------------------------------------------------------------------------
# Routines to extract PDB transformation matrices from PDB file header.
#

# -----------------------------------------------------------------------------
#
def pdb_smtry_matrices(pdb_headers):

  return pdb_remark_matrices(pdb_headers, '290', 'SMTRY')

# -----------------------------------------------------------------------------
#
def pdb_biomt_matrices(pdb_headers):

  return pdb_remark_matrices(pdb_headers, '350', 'BIOMT')
        
# -----------------------------------------------------------------------------
#
def pdb_remark_matrices(pdb_headers, remark_number, tag_name):

  from chimerax.geometry import Places, Place
  h = pdb_headers
  if 'REMARK' not in h:
    return Places([])

  remarks = h['REMARK']
  mtable = {}
  for r in remarks:
    fields = r.split()
    if (len(fields) < 8 or fields[0] != 'REMARK' or
	fields[1] != remark_number or fields[2][:-1] != tag_name):
      continue
    try:
      matrix_num = int(fields[3])
    except ValueError:
      continue
    if matrix_num not in mtable:
      mtable[matrix_num] = [None, None, None]
    try:
      row = int(fields[2][5]) - 1
    except ValueError:
      continue
    if row >= 0 and row <= 2:
      try:
        mtable[matrix_num][row] = tuple(float(x) for x in fields[4:8])
      except ValueError:
        continue

  # Order matrices by matrix number.
  msorted = [nm[1] for nm in sorted(mtable.items())]
  matrices = [mrows for mrows in msorted if mrows.count(None) == 0]

  return Places([Place(m) for m in matrices])

# -----------------------------------------------------------------------------
# The "given" flag indicates which MTRIX records should be returned.
# The PDB MTRIX records have a "given" field which indicates whether or
# not the transformed coordinates are already given in the PDB entry.
#
def pdb_mtrix_matrices(pdb_headers, add_identity = True, given = False):

  h = pdb_headers
  have_matrix = (('MTRIX1' in h) and
		 ('MTRIX2' in h) and
		 ('MTRIX3' in h))
  from chimerax.geometry import Places, Place
  if not have_matrix:
    if add_identity:
      return Places()
    else:
      return Places([])

  row1_list = h['MTRIX1']
  row2_list = h['MTRIX2']
  row3_list = h['MTRIX3']
  if len(row1_list) != len(row2_list) or len(row2_list) != len(row3_list):
    if add_identity:
      return Places()
    else:
      return Places([])
  
  row_triples = [(m1, m2, m3) for m1, m2, m3 in zip(row1_list, row2_list, row3_list)]
  
  mlist = []
  for row_triple in row_triples:
    matrix = []
    for line in row_triple:
      try:
        mrow = [float(x) for x in (line[10:20], line[20:30], line[30:40], line[45:55])]
      except ValueError:
        break
      mgiven = (len(line) >= 60 and line[59] == '1')
      if (mgiven and given) or (not mgiven and not given):
        matrix.append(mrow)
    if len(matrix) == 3:
      mlist.append(Place(matrix))

  if add_identity:
    if not [m for m in mlist if m.is_identity()]:
      # Often there is no MTRIX identity entry
      mlist.append(Place())

  return Places(mlist)

# -----------------------------------------------------------------------------
#
def set_pdb_biomt_remarks(molecule, xforms):

  remarks = []
  h = molecule.metadata
  if 'REMARK' in h:
    remarks = h['REMARK']

  from chimerax.core.buildinfo import version
  template = \
'''REMARK 300 
REMARK 300 BIOMOLECULE: 1 
REMARK 300 SEE REMARK 350 FOR THE AUTHOR PROVIDED AND/OR PROGRAM 
REMARK 300 GENERATED ASSEMBLY INFORMATION FOR THE STRUCTURE IN 
REMARK 300 THIS ENTRY.  THE REMARK MAY ALSO  PROVIDE INFORMATION ON 
REMARK 300 BURIED SURFACE AREA.
REMARK 350
REMARK 350 COORDINATES FOR A COMPLETE MULTIMER  REPRESENTING THE KNOWN
REMARK 350 BIOLOGICALLY SIGNIFICANT OLIGOMERIZATION STATE  OF THE
REMARK 350 MOLECULE CAN BE GENERATED BY APPLYING BIOMT  TRANSFORMATIONS
REMARK 350 GIVEN BELOW.  BOTH NON-CRYSTALLOGRAPHIC  AND
REMARK 350 CRYSTALLOGRAPHIC OPERATIONS ARE GIVEN.
REMARK 350
REMARK 350 BIOMOLECULE: 1
REMARK 350 SOFTWARE USED: UCSF CHIMERAX %s.
REMARK 350 APPLY THE FOLLOWING TO CHAINS: %s
%s'''

  cids = list(set(r.id.chainId for r in molecule.residues))
  cids.sort()
  chains = ', '.join(cids[:10])
  for n in range(10, len(cids), 20):
    chains += ',\nREMARK 350   %s' % ', '.join(cids[n:n+20])

  biomt_template = 'REMARK 350   BIOMT%d %3d %9.6f %9.6f %9.6f   %12.5f'
  mlines = []
  for i, xf in enumerate(xforms):
    tf = xf.matrix
    mlines.extend(biomt_template % ((r+1,i+1,) + tuple(tf[r])) for r in (0,1,2))
  matrices = '\n'.join(mlines)

  rem = template % (version, chains, matrices)
  lines = padded_lines(rem, 80)
  rnew = replace_remarks(remarks, lines, (300,350))
  molecule.setPDBHeader('REMARK', rnew)

# -----------------------------------------------------------------------------
# xform maps global coordinates to new file coordinates.
#
def transform_pdb_biomt_remarks(molecule, xform):

  mtf = xform * molecule.scene_position
  if mtf.is_identity():
    return
  h = molecule.metadata
  tflist = pdb_biomt_matrices(h)
  if len(tflist) == 0:
    return
  if len(tflist) == 1 and tflist[0].is_identity():
    return

  if 'REMARK' in h:
      molecule.original_biomt_remarks = tuple(r for r in h['REMARK']
                                              if remark_number(r) in (300,350))
  tflist = tflist.transform_coordinates(mtf.inverse())
  set_pdb_biomt_remarks(molecule, tflist)

# -----------------------------------------------------------------------------
#
def restore_pdb_biomt_remarks(molecule):

  brem = getattr(molecule, 'original_biomt_remarks', None)
  if brem:
    rnew = replace_remarks(molecule.metadata['REMARK'], brem, (300,350))
    molecule.setPDBHeader('REMARK', rnew)
    delattr(molecule, 'original_biomt_remarks')

# -----------------------------------------------------------------------------
# Read REMARK 350 BIOMT matrices.  Handle matrices for multiple biomolecules
# and also cases where different chains have different matrices applied.
#
# Return a list of biomolecules
#
#  bmlist = (bm1, bm2, ...)
#
# where a biomolecule is groups of chains and transforms for those chains
#
#  bm = (bm_num, ((clist1,tflist1), (clist2,tflist2), ...))
#
# and transforms are numbered
#
# tflist = ((1,m1), (2,m2), ...)
#
def pdb_biomolecules(pdb_headers, remark_number = '350',
                     biomol_tag = 'BIOMOLECULE:', chains_tag = 'CHAINS:',
                     row_tags = {'BIOMT1':0, 'BIOMT2':1, 'BIOMT3':2}):

  rlines = remark_lines(pdb_headers, remark_number)

  mn = None
  tflist = []
  chains = []
  cglist = [(chains,tflist)]
  bmlist = [(1,cglist)]
  for line in rlines:

    # Find biomolecule lines
    i = line.find(biomol_tag)
    if i >= 0:
      i += len(biomol_tag)
      try:
        bm_num = int(line[i:])
      except:
        continue
      tflist = []
      mn = None
      chains = []
      cglist = [(chains,tflist)]
      bmlist.append((bm_num, cglist))   # Remember biomolecule

    # Find chain list lines.
    i = line.find(chains_tag)
    if i >= 0:
      i += len(chains_tag)
      cids = [cid.strip() for cid in line[i:].split(',') if cid.strip()]
      if len(tflist) == 0:
        chains.extend(cids)     # Chain list on multiple lines
      else:
        chains = cids
        tflist = []
        mn = None
        cglist.append((chains,tflist))  # Remember chain group

    # Find matrices
    fields = line.split(None,3)
    if len(fields) == 4 and fields[2] in row_tags:
      r = row_tags[fields[2]]
      rvals = fields[3].split()
      if len(rvals) >= 5:
        try:
          mnum = int(rvals[0])
          mrow = tuple(float(x) for x in rvals[1:5])
        except:
          continue
        if mnum != mn:
          m = [(1,0,0,0),(0,1,0,0),(0,0,1,0)]
          tflist.append((mnum,m))       # Remember transform
          mn = mnum
        m[r] = mrow

  # Remove empty biomolecules and chains with no matrices
  bml = []
  from chimerax.geometry import Place
  for bm_num, cglist in bmlist:
    cgl = []
    for chains, tflist in cglist:
      if tflist:
        cgl.append((chains, [(mnum, Place(m)) for mnum, m in tflist])) 
    if cgl:
      bml.append((bm_num,cgl))
        
  return bml

# -----------------------------------------------------------------------------
#
def remark_lines(pdb_headers, remark_number):

  h = pdb_headers
  if 'REMARK' not in h:
    return []

  rlines = []
  remarks = h['REMARK']
  for r in remarks:
    fields = r.split()
    if len(fields) >= 2 and fields[0] == 'REMARK' and fields[1] == remark_number:
      rlines.append(r)
  return rlines

# -----------------------------------------------------------------------------
#
def padded_lines(string, width):

  pad = ' ' * width
  lines = [(line + pad)[:80] for line in string.split('\n')]
  return lines

# -----------------------------------------------------------------------------
#
def replace_remarks(remarks, lines, remove):

  rnew = [line for line in remarks if remark_number(line) not in remove]
  rnew.extend(lines)
  rnew.sort(lambda a,b: cmp(remark_number(a), remark_number(b)))
  return rnew

# -----------------------------------------------------------------------------
#
def remark_number(line):

  try:
    n = int(line[7:10])
  except:
    n = 1000
  return n

# -----------------------------------------------------------------------------
# PDB SCALEn records allow the origin of the crystal unit cell symmetries
# to be different from the origin of atom coordinates.  It is rare, e.g. PDB 1WAP.
#
def pdb_crystal_origin(pdb_headers):
  h = pdb_headers
  forigin = []
  for s in ('SCALE1', 'SCALE2', 'SCALE3'):
    if not s in h:
      return (0,0,0)
    fields = h[s][0].split()
    if len(fields) < 5:
      return (0,0,0)
    try:
      x = float(fields[4])
    except:
      return (0,0,0)
    forigin.append(x)
  if forigin == [0,0,0]:
    return (0,0,0)

  # Convert fractional unit cell coordinates to atom coordinates
  fx,fy,fz = forigin
  ax,ay,az = pdb_unit_cell_axes(h)
  from chimerax.geometry import linear_combination
  origin = tuple(linear_combination(fx,ax,fy,ay,fz,az))
  
  return origin
    

# -----------------------------------------------------------------------------
# To get all the transformations needed to build the unit cell, multiply all
# SMTRY (crystallographic symmetry) matrices by all MTRIX (non-crystallographic
# symmetry) matrices.
#
# The pack argument can be set to a pair of points
# (molecule-center, unit-cell-origin) and the unit cell transforms will be
# translated to put all molecule centers in the unit cell box.
#
def pdb_unit_cell_matrices(pdb_headers, pack = None, group = False):

  slist = pdb_crystal_symmetry_matrices(pdb_headers)
  mlist = pdb_mtrix_matrices(pdb_headers)

  cp = pdb_crystal_parameters(pdb_headers)
  uc = cp[:6] if cp else None
  from chimerax.crystal import unit_cell_matrices
  smlist = unit_cell_matrices(slist, mlist, uc, pack, group)
  return smlist

# -----------------------------------------------------------------------------
#
def pdb_3x3x3_unit_cell_matrices(pdb_headers, pack = None, group = False):

  cell_axes = pdb_unit_cell_axes(pdb_headers)
  from chimerax.crystal import translation_matrices
  mlist = translation_matrices(cell_axes, ((-1,1), (-1,1), (-1,1)))
  clist = pdb_unit_cell_matrices(pdb_headers, pack = pack, group = group)
  from chimerax.crystal import matrix_products
  plist = matrix_products(mlist, clist, group)
  
  return plist

# -----------------------------------------------------------------------------
# Use SMTRY matrices if available, otherwise use space group matrices.
#
def pdb_crystal_symmetry_matrices(pdb_headers):

  slist = pdb_smtry_matrices(pdb_headers)
  if len(slist) == 0:
    slist = pdb_space_group_matrices(pdb_headers)

  # Handle crystal symmetry origin not equal to atom coordinate origin
  origin = pdb_crystal_origin(pdb_headers)
  if origin != (0,0,0):
    shift = [-x for x in origin]
    from chimerax.geometry import translation
    slist = slist.transform_coordinates(translation(shift))

  return slist

# -----------------------------------------------------------------------------
#
def pdb_space_group_matrices(pdb_headers):

  cp = pdb_crystal_parameters(pdb_headers)
  if cp is None:
    return []
  a, b, c, alpha, beta, gamma, space_group, zvalue = cp
  from chimerax.crystal import space_group_matrices
  sgt = space_group_matrices(space_group, a, b, c, alpha, beta, gamma)
  return sgt

# -----------------------------------------------------------------------------
#
def pdb_cryst1_symmetry_matrices(cryst1_line):

    a, b, c, alpha, beta, gamma, space_group, zvalue = \
       pdb_cryst1_parameters(cryst1_line)

    matrices = symmetry_matrices(space_group, a, b, c, alpha, beta, gamma)
    return matrices

# -----------------------------------------------------------------------------
#
def pdb_crystal_parameters(pdb_headers):

  cryst1_line = cryst1_pdb_record(pdb_headers)
  if not cryst1_line:
    return None
    
  cp = pdb_cryst1_parameters(cryst1_line)
  return cp

# -----------------------------------------------------------------------------
#
def cryst1_pdb_record(pdb_headers):

  h = pdb_headers
  if 'CRYST1' not in h or len(h['CRYST1']) != 1:
    return None

  line = h['CRYST1'][0]
  return line
    
# -----------------------------------------------------------------------------
#
def pdb_cryst1_parameters(cryst1_line):

  line = cryst1_line

  a = float(line[6:15])
  b = float(line[15:24])
  c = float(line[24:33])
  import math
  degrees_to_radians = math.pi / 180
  alpha = degrees_to_radians * float(line[33:40])
  beta = degrees_to_radians * float(line[40:47])
  gamma = degrees_to_radians * float(line[47:54])
  space_group = line[55:66].strip()
  zstr = line[66:70].strip()
  if zstr == '':
    zvalue = None
  else:
    zvalue = int(zstr)

  return a, b, c, alpha, beta, gamma, space_group, zvalue

# -----------------------------------------------------------------------------
#
def pdb_unit_cell_axes(pdb_headers):

  line = cryst1_pdb_record(pdb_headers)
  if line is None:
    return ((1,0,0), (0,1,0), (0,0,1))

  a, b, c, alpha, beta, gamma, space_group, zvalue = pdb_cryst1_parameters(line)
  from chimerax.crystal import unit_cell_axes
  axes = unit_cell_axes(a, b, c, alpha, beta, gamma)
  return axes

# -----------------------------------------------------------------------------
# Return a list of symmetry matrices by adding translations to tflist matrices
# so that they map ref_point into the unit cell box containing ref_point.
# The origin of the unit cell grid is given by grid_origin.
#
def pdb_pack_matrices(pdb_headers, grid_origin, ref_point, tflist):

    cp = pdb_crystal_parameters(pdb_headers)
    if cp is None:
      return tflist
    from chimerax.crystal import pack_unit_cell
    return pack_unit_cell(cp[:6], grid_origin, ref_point, tflist)
