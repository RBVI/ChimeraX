PREREQ_MAKE = 1
TOP	= ../..
include $(TOP)/mk/config.make

# PYTHON_VERSION is in config.make
PYTHON_PATCH_LEVEL = $(PYTHON_VERSION).8
DISTRIBUTION = Python-$(PYTHON_PATCH_LEVEL).tar.xz
SOURCE = $(tmpdir)/Python-$(PYTHON_PATCH_LEVEL)

PIP_VERSION = 20.2.2
WHEEL_VERSION = 0.34.2
SETUPTOOLS_VERSION = 49.4.0

ifdef WIN32
DYNLOAD_DIR = $(bindir)/DLLs
else
DYNLOAD_DIR = $(libdir)/python$(PYTHON_VERSION)/lib-dynload
endif

QUOTE_CC := $(subst ','\'',$(CC) $(TARGET_ARCH))

# Make Python use our compiler options
ENV_CONFIGURE = env CC='$(QUOTE_CC) -I$(includedir) -L$(libdir) -DUSE_DYLD_GLOBAL_NAMESPACE'

ifdef DEBUG
ENV_CONFIGURE += OPT='$(OPT)'
endif

PATCHES	= $(wildcard Python-$(PYTHON_PATCH_LEVEL)-*.patch) \
	  $(wildcard Python-$(PYTHON_PATCH_LEVEL)_$(OS).patch) \
	  $(wildcard Python-$(PYTHON_PATCH_LEVEL)_$(OS)_$(OPENGL_PLATFORM).patch)
ifdef DEBUG
PATCHES += $(wildcard Python-$(PYTHON_PATCH_LEVEL)_debug.patch)
endif

ifeq ($(OS),Linux)
# -Wl,-rpath ends up in shared libraries in addition to executables,
# which we do not want, so only add the rpath when linking the executable
ENV_CONFIGURE += LDFLAGS='$(LDFLAGS)' LINKCC="gcc '-Wl,-rpath,\$$\$$ORIGIN/../lib'"
ifdef HARDENING
ENV_CONFIGURE += CFLAGS='-D_FORTIFY=2 -fstack-protector-strong'
endif
EXTRA_CFLAGS = '-fdebug-prefix-map=$(build_prefix)=.'
CONFIG_OPTIONS += --enable-shared
export LD_LIBRARY_PATH=$(libdir)
# --enable-optimizations causes singularity build to fail (and causes long build times)
# Try reneabling with newer versions of Python after benchmarking it is worth it.
# CONFIG_OPTIONS += --enable-optimizations
endif
ifeq ($(OS),Darwin)
# -Wl,-rpath ends up in shared libraries in addition to executables,
# which we do not want, so we add the rpath later, and set the DYLD_LIBRARY_PATH
# to compensate while we are building.  We also edit the Makefile so that the
# _build_ Python executable, python.exe, gets the correct rpath but none of
# the shared objects should get an explicit rpath (and hence should just use
# the rpath from the ChimeraX/python executable).
export DYLD_LIBRARY_PATH=$(libdir)
ENV_CONFIGURE += PATH='$(bindir)':"$$PATH"
ifndef USE_MAC_FRAMEWORKS
ENV_CONFIGURE += LDFLAGS='$(LDFLAGS)'
CONFIG_OPTIONS += --enable-shared
else
CONFIG_OPTIONS += --enable-framework=$(frameworkdir) --prefix=$(build_prefix)
ENV_CONFIGURE += LDFLAGS='$(LDFLAGS) -F$(frameworkdir)'
pyappdir = $(PYTHON_FRAMEWORK)/Resources/Python.app/Contents/MacOS
endif
endif

ifeq ($(OS),Windows)
ifeq ($(OSARCH),Windows64)
REGTOOL = regtool -w
CONFIG = Release
PLATFORM = x64
else
REGTOOL = regtool
CONFIG = Release
PLATFORM = Win32
endif
CONFIG_PLATFORM = '$(CONFIG)|$(PLATFORM)'

_PYDIR_MACHINE = /machine/SOFTWARE/Python/PythonCore/$(PYTHON_VERSION)/InstallPath/
_PYDIR_USER = /user/SOFTWARE/Python/PythonCore/$(PYTHON_VERSION)/InstallPath/
ifeq ($(shell $(REGTOOL) -q check $(_PYDIR_MACHINE) && echo found),found)
	PYDIR   = $(shell cygpath -u '$(shell $(REGTOOL) get $(_PYDIR_MACHINE))')
endif
ifeq ($(shell $(REGTOOL) -q check $(_PYDIR_USER) && echo found),found)
	PYDIR   = $(shell cygpath -u '$(shell $(REGTOOL) get $(_PYDIR_USER))')
endif
endif # Windows

ifdef DEBUG
CONFIG_OPTIONS += --with-pydebug
endif

ifneq (,$(shell [ ! -e $(TOP)/build_type ] || [ `cat $(TOP)/build_type` = alpha ] && echo found))
# stuff to do only if it is a private or daily build
ifneq (,$(wildcard /usr/include/valgrind/valgrind.h))
CONFIG_OPTIONS += --with-valgrind
endif
endif

all:

install: $(SOURCE)
ifeq ($(OS),Windows)
	#cd $(SOURCE)/PCbuild ; cmd /c build.bat -p $(PLATFORM) 
	#cd $(SOURCE)/PCbuild ; env HOST_PYTHON=`cygpath -m '$(SOURCE)/PCbuild/amd64/python3.exe'` devenv.com pcbuild.sln /build $(CONFIG_PLATFORM) /project _ssl
	test -n '$(PYDIR)'
	@if [ $(PYTHON_PATCH_LEVEL) != $(shell '$(PYDIR)'/python -c 'import sys; print(sys.version.split()[0])') ] ; \
	then \
		echo "Can not find Python $(PYTHON_PATCH_LEVEL)" ; \
		exit 1 ; \
	fi
	$(RSYNC) --exclude='site-packages/*' --exclude='test/*' --exclude=__pycache__ --delete\
	  '$(PYDIR)'/DLLs \
	  '$(PYDIR)'/Lib \
	  '$(PYDIR)'/include \
	  '$(PYDIR)'/libs \
	  '$(PYDIR)'/python.exe \
	  '$(PYDIR)'/pythonw.exe \
	  '$(PYDIR)'/*.dll \
	  '$(bindir)'
	# Leave include and libs in bindir so pip/setuptools will work.
	# Also copy include and lib directories to common locations for
	# our source code.
	$(RSYNC) --delete '$(PYDIR)'/include/* \
		$(includedir)/python$(PYTHON_VERSION)$(PYTHON_ABI)
	$(RSYNC) '$(PYDIR)'/libs/* $(libdir)

else ifdef USE_MAC_FRAMEWORKS
	rm -rf $(frameworkdir)/Python.framework
	cd $(SOURCE) && $(MAKE) EXTRA_CFLAGS=$(EXTRA_CFLAGS) && $(MAKE) -j1 EXTRA_CFLAGS=$(EXTRA_CFLAGS) install
	rm -rf '$(build_prefix)/Applications/Python $(PYTHON_VERSION)'

	# copy bin, include, lib, and share to common location and leave symbolic links
	dir=$(PYTHON_FRAMEWORK)/bin; \
	if [ ! -L $$dir ]; \
	then \
		cd $$dir ; for i in *; do \
			rm -f $(bindir)/$$i; \
		done; \
		$(RSYNC) * $(bindir); \
		cd ..; rm -rf $$dir ; \
		ln -s $(shell python -c 'import os; print(os.path.relpath("$(bindir)", "$(PYTHON_FRAMEWORK)"))') $$dir ; \
	fi
	dir=$(PYTHON_FRAMEWORK)/include; \
	if [ ! -L $$dir ]; \
	then \
		cp -r $$dir/* $(includedir); \
		rm -rf $$dir ; \
		ln -s $(shell python -c 'import os; print(os.path.relpath("$(includedir)", "$(PYTHON_FRAMEWORK)"))') $$dir ; \
	fi
	dir=$(PYTHON_FRAMEWORK)/lib; \
	if [ ! -L $$dir ]; \
	then \
		cp -r $$dir/* $(libdir); \
		rm -rf $$dir ; \
		ln -s $(shell python -c 'import os; print(os.path.relpath("$(libdir)", "$(PYTHON_FRAMEWORK)"))') $$dir ; \
	fi
	dir=$(PYTHON_FRAMEWORK)/share; \
	if [ ! -L $$dir ]; \
	then \
		cp -r $$dir/* $(datadir); \
		rm -rf $$dir ; \
		ln -s $(shell python -c 'import os; print(os.path.relpath("$(datadir)", "$(PYTHON_FRAMEWORK)"))') $$dir ; \
	fi

	# replace python executable with version that doesn't invoke Python.app
	cp $(SOURCE)/python.exe $(PYTHON_EXE)
	install_name_tool -add_rpath '@executable_path/../lib' $(PYTHON_EXE)
	install_name_tool -change $(PYTHON_FRAMEWORK)/Python \
		@executable_path/$(shell python -c 'import os; print(os.path.relpath("$(PYTHON_FRAMEWORK)/Python", "$(bindir)"))') \
		$(PYTHON_EXE)

	$(PYTHON_EXE) fixsymlinks.py $(libdir) \
		$(libdir)/python$(PYTHON_VERSION)/config-$(PYTHON_VERSION)$(PYTHON_ABI)/*

	chmod 644 $(PYTHON_FRAMEWORK)/Python
	install_name_tool -id \
		@executable_path/$(shell python -c 'import os; print(os.path.relpath("$(PYTHON_FRAMEWORK)/Python", "$(bindir)"))') \
		$(PYTHON_FRAMEWORK)/Python
	chmod 444 $(PYTHON_FRAMEWORK)/Python

	# In Python 3.4 framework install only installs a python executable that uses Python.app in the framework.
	install_name_tool -add_rpath \
		@executable_path/$(shell python -c 'import os; print(os.path.relpath("$(libdir)", "$(pyappdir)"))') \
		$(pyappdir)/Python
	install_name_tool -change $(PYTHON_FRAMEWORK)/Python \
		@executable_path/$(shell python -c 'import os; print(os.path.relpath("$(PYTHON_FRAMEWORK)/Python", "$(pyappdir)"))') \
		$(pyappdir)/Python
	$(RSYNC) $(SOURCE)/Misc/valgrind-python.supp $(datadir)
	sed -i -e 's;obj:.*libcrypto.*;obj:*/libcrypto.so.*;' $(datadir)/valgrind-python.supp

else
	# Linux or Mac OS X without framework
	cd $(SOURCE) && $(MAKE) && $(MAKE) install
ifeq ($(OS),Linux)
	-for lib in $(PYTHON_LIBRARY_DIR)/lib-dynload/*.so; do \
		chrpath -d $$lib; \
	done
	chmod 755  $(libdir)/libpython*.so; chrpath -d $(libdir)/libpython*.so
	# convert to RPATH
	if objdump -p $(PYTHON_EXE) | grep RUNPATH > /dev/null; then \
	       $(bindir)/chrpath -C $(PYTHON_EXE); \
	fi
endif
ifeq ($(OS),Darwin)
	install_name_tool -add_rpath '@executable_path/../lib' $(bindir)/python$(PYTHON_VERSION)
	pylib=libpython$(PYTHON_VERSION)$(PYTHON_ABI).dylib ;\
		chmod 644 $(libdir)/$$pylib ;\
		install_name_tool -id @rpath/$$pylib $(libdir)/$$pylib ;\
		chmod 444 $(libdir)/$$pylib
endif
	$(RSYNC) $(SOURCE)/Misc/valgrind-python.supp $(datadir)
	sed -i -e 's;obj:.*libcrypto.*;obj:*/libcrypto.so.*;' $(datadir)/valgrind-python.supp
endif
	# remove unused libraries
	rm -rf $(PYTHON_LIBRARY_DIR)/config-*/*.{a,dylib}

	# Since pip comes with Python 3.5, update it now so installs on
	# Windows will work.  Wheel is needed so bdist_wheel will work.
	$(PYTHON_EXE) -m ensurepip --upgrade
	$(PYTHON_EXE) -m pip install --upgrade pip==$(PIP_VERSION)
	$(PYTHON_EXE) -m pip install --upgrade setuptools==$(SETUPTOOLS_VERSION)
	$(PYTHON_EXE) -m pip install --upgrade wheel==$(WHEEL_VERSION)

	# double check that _ssl was successfully made
	test -f $(DYNLOAD_DIR)/_ssl.*$(PYMOD_EXT)
	# double check that pyexpat was successfully made
	test -f $(DYNLOAD_DIR)/pyexpat.*$(PYMOD_EXT)

app-install:
	$(RSYNC) $(PYTHON_EXE) $(app_bindir)
ifeq ($(OS),Windows)
	# need include and libs so pip install will work
	$(RSYNC) --exclude='site-packages/*' --exclude='test/*' --exclude=__pycache__ --delete\
	  '$(PYDIR)'/DLLs \
	  '$(PYDIR)'/Lib \
	  '$(PYDIR)'/include \
	  '$(PYDIR)'/libs \
	  '$(PYDIR)'/*.dll \
	  $(app_bindir)
else ifdef USE_MAC_FRAMEWORKS
	# next line breaks code signing 1/22/16
	#ln -nf $(app_bindir)/python$(PYTHON_VERSION) $(app_prefix)/MacOS/
	$(RSYNC) $(frameworkdir)/Python.framework $(app_frameworkdir)
	$(RSYNC) --exclude='site-packages/*' --exclude='test/*' --exclude=__pycache__ \
		$(PYTHON_LIBRARY_DIR) $(app_libdir)
	$(RSYNC) $(datadir)/valgrind-python.supp $(app_datadir)
	sed -i -e 's;obj:.*libcrypto.*;obj:*/libcrypto.so.*;' $(app_datadir)/valgrind-python.supp
	$(RSYNC) $(includedir)/python$(PYTHON_VERSION)$(PYTHON_ABI) $(app_includedir)
else
	$(RSYNC) --exclude='site-packages/*' --exclude='test/*' --exclude=__pycache__ \
		$(libdir)/libpython*.$(SHLIB_EXT)* \
		$(PYTHON_LIBRARY_DIR) $(app_libdir)
	$(RSYNC) $(includedir)/python$(PYTHON_VERSION)$(PYTHON_ABI) $(app_includedir)
	$(RSYNC) $(datadir)/valgrind-python.supp $(app_datadir)
	sed -i -e 's;obj:.*libcrypto.*;obj:*/libcrypto.so.*;' $(app_datadir)/valgrind-python.supp
endif
ifneq ($(OS),Windows)
	# remove references to build tree from config
	# we do not build Python on Windows, so no action is needed
	$(APP_PYTHON_EXE) clean_config_vars.py $(build_prefix)
endif
	$(APP_PYTHON_EXE) -m ensurepip --upgrade
	$(APP_PYTHON_EXE) -m pip install --upgrade pip==$(PIP_VERSION)
	$(APP_PYTHON_EXE) -m pip install --upgrade \
		wheel==$(WHEEL_VERSION) \
		setuptools==$(SETUPTOOLS_VERSION)

ifeq ($(OS),Windows)

$(SOURCE):

else

$(SOURCE): $(DISTRIBUTION)
	$(bindir)/7za e -so $(DISTRIBUTION) | tar xf - -C $(tmpdir)

	# avoid bootstrap (files generated by python, but python isn't built)
	cd $(SOURCE) && touch Python/Python-ast.c Include/Python-ast.h

ifneq (,$(PATCHES))
	for p in $(PATCHES); do \
		(cd $(SOURCE) && patch -f -p0) < $$p ; \
	done
endif
	cd $(SOURCE) && $(ENV_CONFIGURE) \
	    ./configure --prefix=$(build_prefix) $(CONFIG_OPTIONS)

ifdef USE_MAC_FRAMEWORKS
	# Remove this when we no longer support El Capitan (10.11)
	cd $(SOURCE) && \
		mv pyconfig.h pyconfig.h.old && \
		sed -e /HAVE_GETENTROPY/d \
			-e /HAVE_CLOCK_GETRES/d \
			-e /HAVE_CLOCK_GETTIME/d \
			-e /HAVE_CLOCK_SETTIME/d \
			< pyconfig.h.old > pyconfig.h
endif
	# Don't use stuff from /usr/local (especially Tcl, Tk, and SSL)
	cd $(SOURCE) && \
	    mv setup.py setup.py.orig ; \
	    sed -e 's;/usr/local;$(build_prefix);' -e 's;/ssl/;/;' < setup.py.orig > setup.py
ifdef USE_MAC_FRAMEWORKS
	# say where to find Tcl and Tk (and any other frameworks)
	(echo ':/framework_dirs =/s:$$: "$(frameworkdir)",:'; echo ':wq') \
	    | env TERM=dumb ex -s $(SOURCE)/setup.py
	(echo ':/^BASECFLAGS/s:$$: -F$(frameworkdir):'; echo ':wq') \
	    | env TERM=dumb ex -s $(SOURCE)/Makefile
	(echo ':/$$@ Programs\/python.o/s::& -Wl,-rpath,$(libdir):'; echo ':wq') \
	    | env TERM=dumb ex -s $(SOURCE)/Makefile
endif

endif

$(DISTRIBUTION):
	$(FETCH_PREREQ) $(PREREQS_ARCHIVE)/python/$(DISTRIBUTION)

upload_new_version:
	$(RSYNC) $(DISTRIBUTION) $(PREREQS_UPLOAD)/python

clean:
	rm -rf $(SOURCE)
